import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { mkdir, rm, writeFile, readFile } from 'fs/promises';
import { existsSync } from 'fs';
import path from 'path';
import { addSectionCommand } from '../src/commands/add-section.js';
import { moveSectionCommand } from '../src/commands/move-section.js';
import { createComponentCommand } from '../src/commands/create-component.js';

describe('Alias functionality', () => {
  const projectRoot = process.cwd();
  const testProjectRoot = path.join(projectRoot, 'temp-test-project');
  const configDir = path.join(testProjectRoot, '.textor');
  const configPath = path.join(configDir, 'config.json');
  const pagesDir = path.join(testProjectRoot, 'src', 'pages');

  // Mock process.cwd() to testProjectRoot
  const originalCwd = process.cwd;

  beforeEach(async () => {
    process.cwd = () => testProjectRoot;
    if (existsSync(testProjectRoot)) await rm(testProjectRoot, { recursive: true, force: true });
    await mkdir(configDir, { recursive: true });
    await mkdir(pagesDir, { recursive: true });
  });

  afterEach(async () => {
    process.cwd = originalCwd;
    if (existsSync(testProjectRoot)) await rm(testProjectRoot, { recursive: true, force: true });
  });

  it('add-section uses custom layout and feature aliases', async () => {
    const customConfig = {
      paths: {
        pages: 'src/pages',
        features: 'src/features',
        components: 'src/components',
        layouts: 'src/layouts'
      },
      importAliases: {
        layouts: 'custom-layouts',
        features: 'custom-features'
      },
      naming: {
        routeExtension: '.astro',
        featureExtension: '.astro'
      },
      signatures: {
        astro: '<!-- @generated by Textor -->'
      },
      features: {
        entry: 'pascal',
        createSubComponentsDir: false,
        createScriptsDir: false
      }
    };
    await writeFile(configPath, JSON.stringify(customConfig));

    await addSectionCommand('/test', 'test-feature', { layout: 'CustomLayout' });

    const routePath = path.join(pagesDir, 'test.astro');
    expect(existsSync(routePath)).toBe(true);

    const content = await readFile(routePath, 'utf-8');
    expect(content).toContain("import CustomLayout from 'custom-layouts/CustomLayout.astro';");
    expect(content).toContain("import TestFeature from 'custom-features/test-feature/TestFeature';");
  });

  it('add-section uses relative paths when aliases are missing', async () => {
    const customConfig = {
      paths: {
        pages: 'src/pages',
        features: 'src/features',
        components: 'src/components',
        layouts: 'src/layouts'
      },
      importAliases: {},
      naming: {
        routeExtension: '.astro',
        featureExtension: '.astro'
      },
      signatures: {
        astro: '<!-- @generated by Textor -->'
      },
      features: {
        entry: 'pascal',
        createSubComponentsDir: false,
        createScriptsDir: false
      }
    };
    await writeFile(configPath, JSON.stringify(customConfig));

    // Test shallow route
    await addSectionCommand('/test', 'test-feature', { layout: 'Main' });
    const routePath = path.join(pagesDir, 'test.astro');
    const content = await readFile(routePath, 'utf-8');
    expect(content).toContain("import Main from '../layouts/Main.astro';");
    expect(content).toContain("import TestFeature from '../features/test-feature/TestFeature';");

    // Test deep route
    await addSectionCommand('/blog/my-post', 'blog/post-feature', { layout: 'Main' });
    const deepRoutePath = path.join(pagesDir, 'blog', 'my-post.astro');
    const deepContent = await readFile(deepRoutePath, 'utf-8');
    expect(deepContent).toContain("import Main from '../../layouts/Main.astro';");
    expect(deepContent).toContain("import BlogPostFeature from '../../features/blog/post-feature/BlogPostFeature';");
  });

  it('move-section updates relative paths correctly', async () => {
    const customConfig = {
      paths: {
        pages: 'src/pages',
        features: 'src/features',
        components: 'src/components',
        layouts: 'src/layouts'
      },
      importAliases: {},
      naming: {
        routeExtension: '.astro',
        featureExtension: '.astro'
      },
      signatures: {
        astro: '<!-- @generated by Textor -->'
      },
      features: {
        entry: 'pascal',
        createSubComponentsDir: false,
        createScriptsDir: false
      }
    };
    await writeFile(configPath, JSON.stringify(customConfig));

    // 1. Create a section
    await addSectionCommand('/old-route', 'old-feature', { layout: 'Main' });
    const oldRoutePath = path.join(pagesDir, 'old-route.astro');
    const oldContent = await readFile(oldRoutePath, 'utf-8');
    expect(oldContent).toContain("import OldFeature from '../features/old-feature/OldFeature';");

    // 2. Move it to a deeper route and different feature
    await moveSectionCommand('/old-route', 'old-feature', '/deep/new-route', 'new/feature', {});
    
    const newRoutePath = path.join(pagesDir, 'deep', 'new-route.astro');
    expect(existsSync(newRoutePath)).toBe(true);
    
    const newContent = await readFile(newRoutePath, 'utf-8');
    expect(newContent).toContain("import NewFeature from '../../features/new/feature/NewFeature';");
  });

  it('move-section updates relative paths when keeping feature', async () => {
    const customConfig = {
      paths: {
        pages: 'src/pages',
        features: 'src/features',
        components: 'src/components',
        layouts: 'src/layouts'
      },
      importAliases: {},
      naming: {
        routeExtension: '.astro',
        featureExtension: '.astro'
      },
      signatures: {
        astro: '<!-- @generated by Textor -->'
      },
      features: {
        entry: 'pascal',
        createSubComponentsDir: false,
        createScriptsDir: false
      }
    };
    await writeFile(configPath, JSON.stringify(customConfig));

    // 1. Create a section
    await addSectionCommand('/old-route', 'my-feature', { layout: 'Main' });
    
    // 2. Move route only to deeper level
    await moveSectionCommand('/old-route', 'my-feature', '/a/b/c/new-route', null, { keepFeature: true });
    
    const newRoutePath = path.join(pagesDir, 'a', 'b', 'c', 'new-route.astro');
    expect(existsSync(newRoutePath)).toBe(true);
    
    const content = await readFile(newRoutePath, 'utf-8');
    // From src/pages/a/b/c/new-route.astro to src/features/my-feature/MyFeature
    // Expected: ../../../../features/my-feature/MyFeature
    expect(content).toContain("import MyFeature from '../../../../features/my-feature/MyFeature';");
  });

  it('create-component uses type instead of interface', async () => {
    const customConfig = {
      paths: {
        pages: 'src/pages',
        features: 'src/features',
        components: 'src/components',
        layouts: 'src/layouts'
      },
      importAliases: {
        layouts: '@/layouts',
        features: '@/features'
      },
      naming: {
        routeExtension: '.astro',
        featureExtension: '.astro',
        componentExtension: '.astro',
        hookExtension: '.ts',
        testExtension: '.test.tsx'
      },
      signatures: {
        astro: '<!-- @generated by Textor -->',
        typescript: '// @generated by Textor'
      },
      components: {
        createSubComponentsDir: false,
        createContext: true,
        createHook: false,
        createTests: false,
        createConfig: false,
        createConstants: false,
        createTypes: false
      }
    };
    await writeFile(configPath, JSON.stringify(customConfig));

    await createComponentCommand('MyComponent', { subComponentsDir: false });

    const componentPath = path.join(testProjectRoot, 'src', 'components', 'MyComponent', 'MyComponent.astro');
    const contextPath = path.join(testProjectRoot, 'src', 'components', 'MyComponent', 'context', 'MyComponentContext.tsx');

    expect(existsSync(componentPath)).toBe(true);
    expect(existsSync(contextPath)).toBe(true);

    const componentContent = await readFile(componentPath, 'utf-8');
    expect(componentContent).toContain('export type Props = {');
    expect(componentContent).not.toContain('interface Props');

    const contextContent = await readFile(contextPath, 'utf-8');
    expect(contextContent).toContain('type MyComponentContextValue = {');
    expect(contextContent).not.toContain('interface MyComponentContextValue');
  });
});
