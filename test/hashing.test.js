import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { mkdir, rm, writeFile, readFile } from 'fs/promises';
import { existsSync } from 'fs';
import path from 'path';
import { addSectionCommand } from '../src/commands/add-section.js';
import { statusCommand } from '../src/commands/status.js';
import { initCommand } from '../src/commands/init.js';

const TEST_DIR = path.resolve('temp-hashing-test');

describe('Hashing: stripGeneratedRegions and useMarkers', () => {
  const originalCwd = process.cwd;

  beforeEach(async () => {
    process.cwd = () => TEST_DIR;
    if (existsSync(TEST_DIR)) {
      await rm(TEST_DIR, { recursive: true, force: true });
    }
    await mkdir(TEST_DIR, { recursive: true });
    await initCommand({ force: true });
  });

  afterEach(async () => {
    process.cwd = originalCwd;
    if (existsSync(TEST_DIR)) {
      await rm(TEST_DIR, { recursive: true, force: true });
    }
  });

  it('should support markers and strip content outside them', async () => {
    const configPath = path.join(TEST_DIR, '.textor/config.json');
    const config = JSON.parse(await readFile(configPath, 'utf-8'));
    config.hashing = {
      normalization: 'stripGeneratedRegions',
      useMarkers: true
    };
    await writeFile(configPath, JSON.stringify(config));

    // 1. Create a section
    await addSectionCommand('/test', 'test-feat', {});
    
    const routePath = path.join(TEST_DIR, 'src/pages/test.astro');
    let content = await readFile(routePath, 'utf-8');
    
    expect(content).toContain('<!-- @generated by Textor:begin -->');
    expect(content).toContain('<!-- @generated by Textor:end -->');

    // 2. Add manual content outside the markers
    const newContent = content + '\n<div>Manual Content</div>';
    await writeFile(routePath, newContent);

    // 3. Status should still be SYNCED
    const logSpy = vi.spyOn(console, 'log').mockImplementation(() => {});
    await statusCommand();
    
    const calls = logSpy.mock.calls.map(call => call[0]);
    expect(calls.some(c => c && c.includes('Synced files: 3'))).toBe(true);
    expect(calls.some(c => c && c.includes('MODIFIED'))).toBe(false);
    
    // 4. Modify content INSIDE markers
    const insideModified = content.replace('TestFeat', 'ModifiedFeat');
    await writeFile(routePath, insideModified);
    
    logSpy.mockClear();
    await statusCommand();
    const calls2 = logSpy.mock.calls.map(call => call[0]);
    expect(calls2.some(c => c && c.includes('MODIFIED (In state, but content changed): 1'))).toBe(true);
  });
});
