import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { rm, mkdir, writeFile } from 'fs/promises';
import { existsSync } from 'fs';
import path from 'path';
import { initCommand } from '../src/commands/init.js';
import { addSectionCommand } from '../src/commands/add-section.js';
import { removeSectionCommand } from '../src/commands/remove-section.js';

const TEST_DIR = path.join(process.cwd(), 'temp-ownership-test');

describe('Ownership Model', () => {
  const originalCwd = process.cwd;

  beforeEach(async () => {
    process.cwd = () => TEST_DIR;
    if (existsSync(TEST_DIR)) {
      await rm(TEST_DIR, { recursive: true, force: true });
    }
    await mkdir(TEST_DIR, { recursive: true });
    await initCommand({ force: true });
  });

  afterEach(async () => {
    process.cwd = originalCwd;
    if (existsSync(TEST_DIR)) {
      await rm(TEST_DIR, { recursive: true, force: true });
    }
  });

  it('should prevent one section from deleting files owned by another section', async () => {
    // 1. Create Section A
    await addSectionCommand('/section-a', 'feat-a', {});
    
    // 2. Create Section B
    await addSectionCommand('/section-b', 'feat-b', {});
    
    // 3. Manually simulate shared file or misconfiguration
    // Let's say Section B somehow has a file that is registered to Section A in state
    const sharedFilePath = path.join(TEST_DIR, 'src/features/feat-b/shared.ts');
    await writeFile(sharedFilePath, '// @generated by Textor\nshared', 'utf-8');
    
    // Register it to Section A
    const { registerFile } = await import('../src/utils/state.js');
    const { calculateHash } = await import('../src/utils/filesystem.js');
    await registerFile(sharedFilePath, {
        kind: 'feature-file',
        hash: calculateHash('// @generated by Textor\nshared'),
        owner: '/section-a'
    });

    // 4. Try to remove Section B
    // It should fail to delete feat-b directory because it contains a file owned by Section A
    await removeSectionCommand('/section-b', 'feat-b', {});
    
    expect(existsSync(path.join(TEST_DIR, 'src/features/feat-b'))).toBe(true);
    expect(existsSync(sharedFilePath)).toBe(true);
  });

  it('should allow deletion if --force is used even with owner mismatch', async () => {
     // 1. Create Section A
     await addSectionCommand('/section-a', 'feat-a', {});
     
     const featAFile = path.join(TEST_DIR, 'src/features/feat-a/FeatA.astro');
     
     // 2. Create a file in a different directory but owned by Section A
     const otherDirPath = path.join(TEST_DIR, 'src/features/other');
     await mkdir(otherDirPath, { recursive: true });
     const otherFile = path.join(otherDirPath, 'other.ts');
     await writeFile(otherFile, '// @generated by Textor\nother', 'utf-8');
     
     const { registerFile } = await import('../src/utils/state.js');
     const { calculateHash } = await import('../src/utils/filesystem.js');
     await registerFile(otherFile, {
         kind: 'feature-file',
         hash: calculateHash('// @generated by Textor\nother'),
         owner: '/section-a'
     });

     // 3. Try to remove 'other' directory while telling the tool it belongs to '/section-b'
     // Since 'other' is not a registered section featurePath, it won't resolve to Section A.
     // It will use '/section-b' as requested owner, which mismatch with '/section-a'
     await removeSectionCommand('/section-b', 'other', {});
     expect(existsSync(otherFile)).toBe(true);
     
     // 4. Force it
     await removeSectionCommand('/section-b', 'other', { force: true });
     expect(existsSync(otherFile)).toBe(false);
  });
});
