import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { mkdir, rm, writeFile, readFile } from 'fs/promises';
import { existsSync } from 'fs';
import path from 'path';
import { addSectionCommand } from '../src/commands/add-section.js';
import { moveSectionCommand } from '../src/commands/move-section.js';
import { syncCommand } from '../src/commands/sync.js';
import { initCommand } from '../src/commands/init.js';

const TEST_DIR = path.resolve('temp-senior-features-test');

describe('Senior Features: kindRules and --scan', () => {
  const originalCwd = process.cwd;

  beforeEach(async () => {
    process.cwd = () => TEST_DIR;
    if (existsSync(TEST_DIR)) {
      await rm(TEST_DIR, { recursive: true, force: true });
    }
    await mkdir(TEST_DIR, { recursive: true });
    await initCommand({ force: true });
  });

  afterEach(async () => {
    process.cwd = originalCwd;
    if (existsSync(TEST_DIR)) {
      await rm(TEST_DIR, { recursive: true, force: true });
    }
  });

  it('should respect kindRules in config', async () => {
    const configPath = path.join(TEST_DIR, '.textor/config.json');
    const config = JSON.parse(await readFile(configPath, 'utf-8'));
    config.kindRules = [
      { match: 'src/features/custom/**', kind: 'custom-kind' },
      { match: '**/special.ts', kind: 'special-file' }
    ];
    await writeFile(configPath, JSON.stringify(config));

    // Create some files
    const customPath = path.join(TEST_DIR, 'src/features/custom/anything.ts');
    await mkdir(path.dirname(customPath), { recursive: true });
    await writeFile(customPath, '// @generated by Textor\ncontent');

    const specialPath = path.join(TEST_DIR, 'src/features/special.ts');
    await mkdir(path.dirname(specialPath), { recursive: true });
    await writeFile(specialPath, '// @generated by Textor\ncontent');

    // Run sync
    await syncCommand({});

    const state = JSON.parse(await readFile(path.join(TEST_DIR, '.textor/state.json'), 'utf-8'));
    expect(state.files['src/features/custom/anything.ts'].kind).toBe('custom-kind');
    expect(state.files['src/features/special.ts'].kind).toBe('special-file');
  });

  it('should update repo-wide imports with --scan in move-section', async () => {
    // 1. Create a section
    await addSectionCommand('/old', 'old-feat', {});
    
    // 2. Create a manual file that imports this feature
    const consumerPath = path.join(TEST_DIR, 'src/consumer.ts');
    await writeFile(consumerPath, "import OldFeat from './features/old-feat/OldFeat';\n<OldFeat />");

    // 3. Move section with --scan
    await moveSectionCommand('/old', 'old-feat', '/new', 'new-feat', { scan: true });

    // 4. Verify consumer was updated
    const consumerContent = await readFile(consumerPath, 'utf-8');
    expect(consumerContent).toContain("import NewFeat from './features/new-feat/NewFeat'");
    expect(consumerContent).toContain("<NewFeat />");
  });

  it('should update repo-wide imports using aliases with --scan', async () => {
    const configPath = path.join(TEST_DIR, '.textor/config.json');
    const config = JSON.parse(await readFile(configPath, 'utf-8'));
    config.importAliases = { features: '@/features' };
    await writeFile(configPath, JSON.stringify(config));

    // 1. Create a section (it will use aliases in route)
    await addSectionCommand('/old', 'old-feat', {});
    
    // 2. Create a manual file that uses the alias
    const consumerPath = path.join(TEST_DIR, 'src/consumer.ts');
    await writeFile(consumerPath, "import OldFeat from '@/features/old-feat/OldFeat';\n<OldFeat />");

    // 3. Move section with --scan
    await moveSectionCommand('/old', 'old-feat', '/new', 'new-feat', { scan: true });

    // 4. Verify consumer was updated
    const consumerContent = await readFile(consumerPath, 'utf-8');
    expect(consumerContent).toContain("import NewFeat from '@/features/new-feat/NewFeat'");
    expect(consumerContent).toContain("<NewFeat />");
  });
});
