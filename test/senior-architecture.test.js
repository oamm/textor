import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { rm, mkdir, readFile, writeFile } from 'fs/promises';
import { existsSync } from 'fs';
import path from 'path';
import { initCommand } from '../src/commands/init.js';
import { addSectionCommand } from '../src/commands/add-section.js';
import { createComponentCommand } from '../src/commands/create-component.js';
import { statusCommand } from '../src/commands/status.js';
import { calculateHash } from '../src/utils/filesystem.js';
import { loadState, saveState } from '../src/utils/state.js';
import * as gitUtils from '../src/utils/git.js';

const TEST_DIR = path.join(process.cwd(), 'temp-senior-test');

describe('Senior Architecture & Folders', () => {
  const originalCwd = process.cwd;

  beforeEach(async () => {
    process.cwd = () => TEST_DIR;
    if (existsSync(TEST_DIR)) {
      await rm(TEST_DIR, { recursive: true, force: true });
    }
    await mkdir(TEST_DIR, { recursive: true });
    await initCommand({ force: true });
  });

  afterEach(async () => {
    process.cwd = originalCwd;
    if (existsSync(TEST_DIR)) {
      await rm(TEST_DIR, { recursive: true, force: true });
    }
    vi.restoreAllMocks();
  });

  it('add-section should support senior folders', async () => {
    await addSectionCommand('/dashboard', 'users/dashboard', { 
      layout: 'Main',
      api: true,
      services: true,
      schemas: true,
      tests: true,
      readme: true,
      stories: true,
      hooks: true,
      context: true,
      types: true,
      index: true
    });

    const featureDir = path.join(TEST_DIR, 'src/features/users/dashboard');
    
    expect(existsSync(path.join(featureDir, 'api/index.ts'))).toBe(true);
    expect(existsSync(path.join(featureDir, 'services/index.ts'))).toBe(true);
    expect(existsSync(path.join(featureDir, 'schemas/index.ts'))).toBe(true);
    expect(existsSync(path.join(featureDir, 'hooks/useUsersDashboard.ts'))).toBe(true);
    expect(existsSync(path.join(featureDir, 'context/UsersDashboardContext.tsx'))).toBe(true);
    expect(existsSync(path.join(featureDir, 'types/index.ts'))).toBe(true);
    expect(existsSync(path.join(featureDir, '__tests__/UsersDashboard.test.tsx'))).toBe(true);
    expect(existsSync(path.join(featureDir, 'README.md'))).toBe(true);
    expect(existsSync(path.join(featureDir, 'UsersDashboard.stories.tsx'))).toBe(true);
    expect(existsSync(path.join(featureDir, 'index.ts'))).toBe(true);
    expect(existsSync(path.join(featureDir, 'UsersDashboard.astro'))).toBe(true);
  });

  it('should save state atomically (temp and rename)', async () => {
    const state = { test: true, files: {} };
    await saveState(state);
    const statePath = path.join(TEST_DIR, '.textor', 'state.json');
    expect(existsSync(statePath)).toBe(true);
    const saved = JSON.parse(await readFile(statePath, 'utf-8'));
    expect(saved.test).toBe(true);
  });

  it('should normalize EOL in hashing', async () => {
    const contentLF = 'line1\nline2';
    const contentCRLF = 'line1\r\nline2';
    
    const hashLF = calculateHash(contentLF, 'normalizeEOL');
    const hashCRLF = calculateHash(contentCRLF, 'normalizeEOL');
    
    expect(hashLF).toBe(hashCRLF);
  });

  it('status command should report drift correctly', async () => {
    await addSectionCommand('/test', 'test-feat', {});
    const routePath = 'src/pages/test.astro';
    const fullRoutePath = path.join(TEST_DIR, routePath);
    
    await writeFile(fullRoutePath, '<!-- @generated by Textor -->\nMODIFIED', 'utf-8');
    
    const untrackedPath = path.join(TEST_DIR, 'src/components/Untracked.tsx');
    await mkdir(path.dirname(untrackedPath), { recursive: true });
    await writeFile(untrackedPath, '// @generated by Textor\nUntracked', 'utf-8');
    
    const orphanedPath = path.join(TEST_DIR, 'src/components/Orphaned.tsx');
    await writeFile(orphanedPath, 'No Signature', 'utf-8');

    const logSpy = vi.spyOn(console, 'log').mockImplementation(() => {});
    
    await statusCommand();
    
    const calls = logSpy.mock.calls.map(call => call[0]);
    expect(calls.some(c => c && c.includes('MODIFIED'))).toBe(true);
    expect(calls.some(c => c && c.includes('src/pages/test.astro'))).toBe(true);
    expect(calls.some(c => c && c.includes('UNTRACKED'))).toBe(true);
    expect(calls.some(c => c && c.includes('src/components/Untracked.tsx'))).toBe(true);
    expect(calls.some(c => c && c.includes('ORPHANED'))).toBe(true);
    expect(calls.some(c => c && c.includes('src/components/Orphaned.tsx'))).toBe(true);
  });

  it('should track ownership and template version', async () => {
    await addSectionCommand('/my-route', 'my-feat', {});
    const state = await loadState();
    
    const routeFile = state.files['src/pages/my-route.astro'];
    expect(routeFile.owner).toBe('/my-route');
    expect(routeFile.templateVersion).toBe('1.0.0');
    
    const featureFile = state.files['src/features/my-feat/MyFeat.astro'];
    expect(featureFile.owner).toBe('/my-route');
  });

  it('should fail destructive commands if repo is dirty and requireCleanRepo is true', async () => {
    const configPath = path.join(TEST_DIR, '.textor', 'config.json');
    const config = JSON.parse(await readFile(configPath, 'utf-8'));
    config.git = { requireCleanRepo: true };
    await writeFile(configPath, JSON.stringify(config));
    
    vi.spyOn(gitUtils, 'isRepoClean').mockResolvedValue(false);
    
    const { removeSectionCommand } = await import('../src/commands/remove-section.js');
    
    await expect(removeSectionCommand('/test', 'test-feat', {}))
      .rejects.toThrow('Git repository is not clean');
  });
});
