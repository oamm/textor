import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { mkdir, rm, readFile, writeFile } from 'fs/promises';
import { existsSync } from 'fs';
import path from 'path';
import { initCommand } from '../src/commands/init.js';
import { addSectionCommand } from '../src/commands/add-section.js';
import { syncCommand } from '../src/commands/sync.js';
import { calculateHash } from '../src/utils/filesystem.js';
import { saveState } from '../src/utils/state.js';

const TEST_DIR = path.join(process.cwd(), 'temp-sync-test');

describe('Sync Command', () => {
  const originalCwd = process.cwd;

  beforeEach(async () => {
    process.cwd = () => TEST_DIR;
    if (existsSync(TEST_DIR)) {
      await rm(TEST_DIR, { recursive: true, force: true });
    }
    await mkdir(TEST_DIR, { recursive: true });
    await initCommand({ force: true });
    await saveState({ sections: [], components: [], files: {} });
  });

  afterEach(async () => {
    process.cwd = originalCwd;
    if (existsSync(TEST_DIR)) {
      await rm(TEST_DIR, { recursive: true, force: true });
    }
  });

  it('should add files with signature that are not in state', async () => {
    // 1. Manually create a file with signature but don't add to state
    const filePath = path.join(TEST_DIR, 'src/components/Manual.astro');
    const content = '<!-- @generated by Textor -->\n<div>Manual</div>';
    await mkdir(path.dirname(filePath), { recursive: true });
    await writeFile(filePath, content, 'utf-8');

    // 2. Run sync
    await syncCommand({});

    // 3. Verify it was added to state
    const statePath = path.join(TEST_DIR, '.textor', 'state.json');
    const state = JSON.parse(await readFile(statePath, 'utf-8'));
    expect(state.files['src/components/Manual.astro']).toBeDefined();
    expect(state.files['src/components/Manual.astro'].hash).toBe(calculateHash(content));
    expect(state.files['src/components/Manual.astro'].kind).toBe('component');
  });

  it('should update hashes for modified files with signature', async () => {
    // 1. Add a section normally
    await addSectionCommand('/test', 'test-feat', {});
    const routePath = 'src/pages/test.astro';
    const fullRoutePath = path.join(TEST_DIR, routePath);
    
    const statePath = path.join(TEST_DIR, '.textor', 'state.json');
    let state = JSON.parse(await readFile(statePath, 'utf-8'));
    const oldHash = state.files[routePath].hash;

    // 2. Modify the file
    const newContent = '<!-- @generated by Textor -->\n<div>Modified</div>';
    await writeFile(fullRoutePath, newContent, 'utf-8');
    const newHash = calculateHash(newContent);

    // 3. Run sync
    await syncCommand({});

    // 4. Verify hash was updated
    state = JSON.parse(await readFile(statePath, 'utf-8'));
    expect(state.files[routePath].hash).toBe(newHash);
    expect(state.files[routePath].hash).not.toBe(oldHash);
  });

  it('should remove missing files from state', async () => {
    // 1. Add a section
    await addSectionCommand('/test', 'test-feat', {});
    const routePath = 'src/pages/test.astro';
    const fullRoutePath = path.join(TEST_DIR, routePath);

    // 2. Delete the file from disk
    await rm(fullRoutePath);

    // 3. Run sync
    await syncCommand({});

    // 4. Verify it was removed from state
    const statePath = path.join(TEST_DIR, '.textor', 'state.json');
    const state = JSON.parse(await readFile(statePath, 'utf-8'));
    expect(state.files[routePath]).toBeUndefined();
  });

  it('should not include files without signature unless --include-all is used', async () => {
    const filePath = path.join(TEST_DIR, 'src/components/Handwritten.astro');
    const content = '<div>Handwritten</div>';
    await mkdir(path.dirname(filePath), { recursive: true });
    await writeFile(filePath, content, 'utf-8');

    // Sync without --include-all
    await syncCommand({});
    let state = JSON.parse(await readFile(path.join(TEST_DIR, '.textor', 'state.json'), 'utf-8'));
    expect(state.files['src/components/Handwritten.astro']).toBeUndefined();

    // Sync with --include-all
    await syncCommand({ includeAll: true });
    state = JSON.parse(await readFile(path.join(TEST_DIR, '.textor', 'state.json'), 'utf-8'));
    expect(state.files['src/components/Handwritten.astro']).toBeDefined();
  });

  it('should not update modified files without signature unless --force is used', async () => {
    // 1. Create a file in state without signature (using includeAll)
    const filePath = 'src/components/Legacy.astro';
    const fullPath = path.join(TEST_DIR, filePath);
    const content = '<div>Legacy</div>';
    await mkdir(path.dirname(fullPath), { recursive: true });
    await writeFile(fullPath, content, 'utf-8');
    
    await syncCommand({ includeAll: true });
    
    const statePath = path.join(TEST_DIR, '.textor', 'state.json');
    let state = JSON.parse(await readFile(statePath, 'utf-8'));
    const initialHash = state.files[filePath].hash;

    // 2. Modify it
    await writeFile(fullPath, '<div>Modified Legacy</div>', 'utf-8');

    // 3. Sync without force
    await syncCommand({});
    state = JSON.parse(await readFile(statePath, 'utf-8'));
    expect(state.files[filePath].hash).toBe(initialHash);

    // 4. Sync with force
    await syncCommand({ force: true });
    state = JSON.parse(await readFile(statePath, 'utf-8'));
    expect(state.files[filePath].hash).not.toBe(initialHash);
    expect(state.files[filePath].hash).toBe(calculateHash('<div>Modified Legacy</div>'));
  });
});
