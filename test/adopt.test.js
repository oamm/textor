import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { mkdir, rm, readFile, writeFile } from 'fs/promises';
import { existsSync } from 'fs';
import path from 'path';
import { initCommand } from '../src/commands/init.js';
import { adoptCommand } from '../src/commands/adopt.js';
import { calculateHash } from '../src/utils/filesystem.js';
import { saveState } from '../src/utils/state.js';

const TEST_DIR = path.join(process.cwd(), 'temp-adopt-test');

describe('Adopt Command', () => {
  const originalCwd = process.cwd;

  beforeEach(async () => {
    process.cwd = () => TEST_DIR;
    if (existsSync(TEST_DIR)) {
      await rm(TEST_DIR, { recursive: true, force: true });
    }
    await mkdir(TEST_DIR, { recursive: true });
    await initCommand({ force: true });
    await saveState({ sections: [], components: [], files: {} });
  });

  afterEach(async () => {
    process.cwd = originalCwd;
    if (existsSync(TEST_DIR)) {
      await rm(TEST_DIR, { recursive: true, force: true });
    }
  });

  it('should adopt a single file and add signature', async () => {
    const filePath = path.join(TEST_DIR, 'src/components/Manual/Manual.astro');
    const content = '<div>Manual</div>';
    await mkdir(path.dirname(filePath), { recursive: true });
    await writeFile(filePath, content, 'utf-8');

    await adoptCommand('src/components/Manual/Manual.astro', {});

    const statePath = path.join(TEST_DIR, '.textor', 'state.json');
    const state = JSON.parse(await readFile(statePath, 'utf-8'));
    
    expect(state.files['src/components/Manual/Manual.astro']).toBeDefined();
    
    const newContent = await readFile(filePath, 'utf-8');
    expect(newContent).toContain('<!-- @generated by Textor -->');
    expect(newContent).toContain(content);
    expect(state.files['src/components/Manual/Manual.astro'].hash).toBe(calculateHash(newContent));
    
    // Check component reconstruction
    expect(state.components.length).toBe(1);
    expect(state.components[0].name).toBe('Manual');
  });

  it('should adopt a directory and all files inside', async () => {
    const dirPath = path.join(TEST_DIR, 'src/components/Comp');
    await mkdir(dirPath, { recursive: true });
    await writeFile(path.join(dirPath, 'Comp.astro'), '<div>Comp</div>', 'utf-8');
    await writeFile(path.join(dirPath, 'index.ts'), 'export {}', 'utf-8');

    await adoptCommand('src/components/Comp', {});

    const statePath = path.join(TEST_DIR, '.textor', 'state.json');
    const state = JSON.parse(await readFile(statePath, 'utf-8'));

    expect(state.files['src/components/Comp/Comp.astro']).toBeDefined();
    expect(state.files['src/components/Comp/index.ts']).toBeDefined();
    
    expect(await readFile(path.join(dirPath, 'Comp.astro'), 'utf-8')).toContain('<!-- @generated by Textor -->');
    expect(await readFile(path.join(dirPath, 'index.ts'), 'utf-8')).toContain('// @generated by Textor');
    
    expect(state.components.length).toBe(1);
    expect(state.components[0].name).toBe('Comp');
  });

  it('should adopt all untracked files with --all', async () => {
    await mkdir(path.join(TEST_DIR, 'src/components/C1'), { recursive: true });
    await writeFile(path.join(TEST_DIR, 'src/components/C1/C1.astro'), '<div>C1</div>', 'utf-8');
    
    await mkdir(path.join(TEST_DIR, 'src/pages'), { recursive: true });
    await writeFile(path.join(TEST_DIR, 'src/pages/p1.astro'), '<div>P1</div>', 'utf-8');

    await adoptCommand(null, { all: true });

    const statePath = path.join(TEST_DIR, '.textor', 'state.json');
    const state = JSON.parse(await readFile(statePath, 'utf-8'));

    expect(state.files['src/components/C1/C1.astro']).toBeDefined();
    expect(state.files['src/pages/p1.astro']).toBeDefined();
    
    expect(state.components.length).toBe(1);
    expect(state.components[0].name).toBe('C1');
  });

  it('should reconstruct sections after adopting page and feature', async () => {
    // 1. Create untracked page and feature
    await mkdir(path.join(TEST_DIR, 'src/pages'), { recursive: true });
    await writeFile(path.join(TEST_DIR, 'src/pages/users.astro'), '<div>Users</div>', 'utf-8');
    
    await mkdir(path.join(TEST_DIR, 'src/features/users'), { recursive: true });
    await writeFile(path.join(TEST_DIR, 'src/features/users/UserList.astro'), '<div>List</div>', 'utf-8');

    // 2. Adopt them
    await adoptCommand(null, { all: true });

    const statePath = path.join(TEST_DIR, '.textor', 'state.json');
    const state = JSON.parse(await readFile(statePath, 'utf-8'));

    // 3. Verify section was reconstructed
    expect(state.sections.length).toBe(1);
    expect(state.sections[0].route).toBe('/users');
    expect(state.sections[0].name).toBe('users');
  });

  it('should adopt a component by its name', async () => {
    const compPath = path.join(TEST_DIR, 'src/components/NamedComp');
    await mkdir(compPath, { recursive: true });
    await writeFile(path.join(compPath, 'NamedComp.astro'), '<div>Named</div>', 'utf-8');

    await adoptCommand('NamedComp', {});

    const statePath = path.join(TEST_DIR, '.textor', 'state.json');
    const state = JSON.parse(await readFile(statePath, 'utf-8'));
    expect(state.files['src/components/NamedComp/NamedComp.astro']).toBeDefined();
    expect(state.components.find(c => c.name === 'NamedComp')).toBeDefined();
  });

  it('should adopt a section by its route', async () => {
    const pagePath = path.join(TEST_DIR, 'src/pages/about.astro');
    await mkdir(path.dirname(pagePath), { recursive: true });
    await writeFile(pagePath, '<div>About</div>', 'utf-8');
    
    const featPath = path.join(TEST_DIR, 'src/features/about');
    await mkdir(featPath, { recursive: true });
    await writeFile(path.join(featPath, 'About.astro'), '<div>About Feat</div>', 'utf-8');

    // Adopt using route
    await adoptCommand('/about', {});

    const statePath = path.join(TEST_DIR, '.textor', 'state.json');
    const state = JSON.parse(await readFile(statePath, 'utf-8'));
    expect(state.files['src/pages/about.astro']).toBeDefined();
    // Note: adopting by route /about only finds the page by default unless the feature has same name
    // In my logic, it also tries featPath with identifier
    
    // Since I called adoptCommand('/about', {}), it should:
    // 1. Try path /about -> fail
    // 2. Try component about -> fail
    // 3. Try feature about -> found!
    // 4. Try page about.astro -> found!
    
    expect(state.files['src/features/about/About.astro']).toBeDefined();
    expect(state.sections.find(s => s.route === '/about')).toBeDefined();
  });

  it('should not add duplicate signature if already present', async () => {
    const filePath = path.join(TEST_DIR, 'src/components/Signed.astro');
    const signature = '<!-- @generated by Textor -->';
    const content = `${signature}\n<div>Signed</div>`;
    await mkdir(path.dirname(filePath), { recursive: true });
    await writeFile(filePath, content, 'utf-8');

    await adoptCommand('src/components/Signed.astro', {});

    const newContent = await readFile(filePath, 'utf-8');
    const signatureCount = (newContent.match(new RegExp(signature, 'g')) || []).length;
    expect(signatureCount).toBe(1);
  });

  it('should respect dry-run', async () => {
    const filePath = path.join(TEST_DIR, 'src/components/Dry.astro');
    const content = '<div>Dry</div>';
    await mkdir(path.dirname(filePath), { recursive: true });
    await writeFile(filePath, content, 'utf-8');

    await adoptCommand('src/components/Dry.astro', { dryRun: true });

    const statePath = path.join(TEST_DIR, '.textor', 'state.json');
    const state = JSON.parse(await readFile(statePath, 'utf-8'));
    
    expect(state.files['src/components/Dry.astro']).toBeUndefined();
    expect(await readFile(filePath, 'utf-8')).not.toContain('<!-- @generated by Textor -->');
  });
});
