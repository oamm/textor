import { readFile, writeFile, mkdir, unlink, rmdir, rename, readdir, stat, rm } from 'fs/promises';
import { existsSync } from 'fs';
import path from 'path';

export async function isTextorGenerated(filePath) {
  if (!existsSync(filePath)) {
    return false;
  }

  try {
    const content = await readFile(filePath, 'utf-8');
    return content.includes('@generated by Textor');
  } catch {
    return false;
  }
}

export async function ensureNotExists(filePath, force = false) {
  if (existsSync(filePath)) {
    if (!force) {
      throw new Error(
        `File already exists: ${filePath}\n` +
        `Use --force to overwrite.`
      );
    }
  }
}

export async function ensureDir(dirPath) {
  await mkdir(dirPath, { recursive: true });
}

export async function safeDelete(filePath, force = false) {
  if (!existsSync(filePath)) {
    return { deleted: false, reason: 'not-found' };
  }

  const isGenerated = await isTextorGenerated(filePath);
  
  if (!isGenerated && !force) {
    return { 
      deleted: false, 
      reason: 'not-generated',
      message: `Refusing to delete ${filePath} - not generated by Textor. Use --force to override.`
    };
  }

  await unlink(filePath);
  return { deleted: true };
}

async function isSafeToDeleteDir(dirPath) {
  try {
    const files = await readdir(dirPath);
    
    const results = await Promise.all(
      files.map(async file => {
        const filePath = path.join(dirPath, file);
        const stats = await stat(filePath);
        
        if (stats.isDirectory()) {
          return await isSafeToDeleteDir(filePath);
        }
        
        return await isTextorGenerated(filePath);
      })
    );

    return results.every(Boolean);
  } catch {
    return false;
  }
}

export async function safeDeleteDir(dirPath, force = false) {
  if (!existsSync(dirPath)) {
    return { deleted: false, reason: 'not-found' };
  }

  const isSafe = force || await isSafeToDeleteDir(dirPath);
  
  if (isSafe) {
    await rm(dirPath, { recursive: true, force: true });
    return { deleted: true };
  }

  return {
    deleted: false,
    reason: 'contains-non-generated',
    message: `Directory contains non-generated files: ${dirPath}. Use --force to override.`
  };
}

export async function writeFileWithSignature(filePath, content, signature) {
  await ensureDir(path.dirname(filePath));
  
  const contentWithSignature = signature + '\n' + content;
  await writeFile(filePath, contentWithSignature, 'utf-8');
}

export async function updateSignature(filePath, oldPath, newPath) {
  if (!existsSync(filePath)) {
    return;
  }

  let content = await readFile(filePath, 'utf-8');
  
  content = content.replace(
    new RegExp(oldPath.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'),
    newPath
  );
  
  await writeFile(filePath, content, 'utf-8');
}

export async function safeMove(fromPath, toPath, force = false) {
  if (!existsSync(fromPath)) {
    throw new Error(`Source file not found: ${fromPath}`);
  }

  if (existsSync(toPath) && !force) {
    throw new Error(
      `Destination already exists: ${toPath}\n` +
      `Use --force to overwrite.`
    );
  }

  const isGenerated = await isTextorGenerated(fromPath);
  if (!isGenerated && !force) {
    throw new Error(
      `Refusing to move ${fromPath} - not generated by Textor.\n` +
      `Use --force to override.`
    );
  }

  await ensureDir(path.dirname(toPath));
  await rename(fromPath, toPath);
  
  await updateSignature(toPath, fromPath, toPath);
}

export async function isEmptyDir(dirPath) {
  if (!existsSync(dirPath)) {
    return true;
  }

  const files = await readdir(dirPath);
  return files.length === 0;
}

/**
 * Safely joins path segments and ensures the result is within the basePath.
 * @param {string} basePath The base directory that must contain the result
 * @param {...string} segments Path segments to join
 * @returns {string} The joined path
 * @throws {Error} If a path traversal attempt is detected
 */
export function secureJoin(basePath, ...segments) {
  const joinedPath = path.join(basePath, ...segments);
  const resolvedBase = path.resolve(basePath);
  const resolvedJoined = path.resolve(joinedPath);
  
  const relative = path.relative(resolvedBase, resolvedJoined);
  
  if (relative.startsWith('..') || path.isAbsolute(relative)) {
    throw new Error(`Security error: Path traversal attempt detected: ${joinedPath} is outside of ${basePath}`);
  }
  
  return joinedPath;
}

export async function cleanupEmptyDirs(dirPath, rootPath) {
  const normalizedDir = path.resolve(dirPath);
  const normalizedRoot = path.resolve(rootPath);
  
  if (normalizedDir === normalizedRoot || !normalizedDir.startsWith(normalizedRoot)) {
    return;
  }

  if (await isEmptyDir(normalizedDir)) {
    await rmdir(normalizedDir);
    await cleanupEmptyDirs(path.dirname(normalizedDir), rootPath);
  }
}
