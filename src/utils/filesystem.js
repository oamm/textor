import { readFile, writeFile, mkdir, unlink, rmdir, rename, readdir, stat } from 'fs/promises';
import { existsSync } from 'fs';
import path from 'path';

export async function isTextorGenerated(filePath) {
  if (!existsSync(filePath)) {
    return false;
  }

  try {
    const content = await readFile(filePath, 'utf-8');
    return content.includes('@generated by Textor');
  } catch {
    return false;
  }
}

export async function ensureNotExists(filePath, force = false) {
  if (existsSync(filePath)) {
    if (!force) {
      throw new Error(
        `File already exists: ${filePath}\n` +
        `Use --force to overwrite.`
      );
    }
  }
}

export async function ensureDir(dirPath) {
  await mkdir(dirPath, { recursive: true });
}

export async function safeDelete(filePath, force = false) {
  if (!existsSync(filePath)) {
    return { deleted: false, reason: 'not-found' };
  }

  const isGenerated = await isTextorGenerated(filePath);
  
  if (!isGenerated && !force) {
    return { 
      deleted: false, 
      reason: 'not-generated',
      message: `Refusing to delete ${filePath} - not generated by Textor. Use --force to override.`
    };
  }

  await unlink(filePath);
  return { deleted: true };
}

export async function safeDeleteDir(dirPath, force = false) {
  if (!existsSync(dirPath)) {
    return { deleted: false, reason: 'not-found' };
  }

  const files = await readdir(dirPath);
  
  if (files.length === 0) {
    await rmdir(dirPath);
    return { deleted: true };
  }

  const allGenerated = await Promise.all(
    files.map(async file => {
      const filePath = path.join(dirPath, file);
      const stats = await stat(filePath);
      
      if (stats.isDirectory()) {
        return false;
      }
      
      return await isTextorGenerated(filePath);
    })
  );

  if (allGenerated.every(Boolean) || force) {
    await Promise.all(
      files.map(async file => {
        const filePath = path.join(dirPath, file);
        const stats = await stat(filePath);
        
        if (stats.isFile()) {
          await unlink(filePath);
        }
      })
    );
    
    await rmdir(dirPath);
    return { deleted: true };
  }

  return {
    deleted: false,
    reason: 'contains-non-generated',
    message: `Directory contains non-generated files: ${dirPath}. Use --force to override.`
  };
}

export async function writeFileWithSignature(filePath, content, signature) {
  await ensureDir(path.dirname(filePath));
  
  const contentWithSignature = signature + '\n' + content;
  await writeFile(filePath, contentWithSignature, 'utf-8');
}

export async function updateSignature(filePath, oldPath, newPath) {
  if (!existsSync(filePath)) {
    return;
  }

  let content = await readFile(filePath, 'utf-8');
  
  content = content.replace(
    new RegExp(oldPath.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'),
    newPath
  );
  
  await writeFile(filePath, content, 'utf-8');
}

export async function safeMove(fromPath, toPath, force = false) {
  if (!existsSync(fromPath)) {
    throw new Error(`Source file not found: ${fromPath}`);
  }

  if (existsSync(toPath) && !force) {
    throw new Error(
      `Destination already exists: ${toPath}\n` +
      `Use --force to overwrite.`
    );
  }

  const isGenerated = await isTextorGenerated(fromPath);
  if (!isGenerated && !force) {
    throw new Error(
      `Refusing to move ${fromPath} - not generated by Textor.\n` +
      `Use --force to override.`
    );
  }

  await ensureDir(path.dirname(toPath));
  await rename(fromPath, toPath);
  
  await updateSignature(toPath, fromPath, toPath);
}

export async function isEmptyDir(dirPath) {
  if (!existsSync(dirPath)) {
    return true;
  }

  const files = await readdir(dirPath);
  return files.length === 0;
}

export async function cleanupEmptyDirs(dirPath, rootPath) {
  const normalizedDir = path.resolve(dirPath);
  const normalizedRoot = path.resolve(rootPath);
  
  if (normalizedDir === normalizedRoot || !normalizedDir.startsWith(normalizedRoot)) {
    return;
  }

  if (await isEmptyDir(normalizedDir)) {
    await rmdir(normalizedDir);
    await cleanupEmptyDirs(path.dirname(normalizedDir), rootPath);
  }
}
