import { readFile, writeFile, mkdir, unlink, rmdir, rename, readdir, stat, rm } from 'fs/promises';
import { existsSync } from 'fs';
import path from 'path';
import { createHash } from 'crypto';
import { exec } from 'child_process';
import { promisify } from 'util';
import { toPascalCase } from './naming.js';

const execAsync = promisify(exec);

export function calculateHash(content, normalization = 'normalizeEOL') {
  let normalizedContent = content;
  
  if (normalization === 'stripGeneratedRegions') {
    // Extract all content between :begin and :end markers
    const beginMarker = /@generated by Textor:begin/g;
    const endMarker = /@generated by Textor:end/g;
    
    const regions = [];
    let match;
    const beginIndices = [];
    while ((match = beginMarker.exec(content)) !== null) {
      beginIndices.push(match.index + match[0].length);
    }
    
    const endIndices = [];
    while ((match = endMarker.exec(content)) !== null) {
      endIndices.push(match.index);
    }
    
    if (beginIndices.length > 0 && beginIndices.length === endIndices.length) {
      for (let i = 0; i < beginIndices.length; i++) {
        regions.push(content.slice(beginIndices[i], endIndices[i]));
      }
      normalizedContent = regions.join('\n');
    }
    // Fall back to full content if markers are missing or mismatched
  }

  if (normalization === 'normalizeEOL' || normalization === 'stripGeneratedRegions') {
    normalizedContent = normalizedContent.replace(/\r\n/g, '\n');
  }
  
  return createHash('sha256').update(normalizedContent).digest('hex');
}

export async function isTextorGenerated(filePath, customSignatures = []) {
  if (!existsSync(filePath)) {
    return false;
  }

  try {
    const content = await readFile(filePath, 'utf-8');
    const signatures = ['@generated by Textor', ...customSignatures];
    return signatures.some(sig => content.includes(sig));
  } catch {
    return false;
  }
}

export async function verifyFileIntegrity(filePath, expectedHash, options = {}) {
  const { 
    force = false, 
    acceptChanges = false, 
    normalization = 'normalizeEOL',
    owner = null,
    actualOwner = null
  } = options;
  
  if (force) return { valid: true };

  if (owner && actualOwner && owner !== actualOwner) {
    return {
      valid: false,
      reason: 'wrong-owner',
      message: `Refusing to operate on ${filePath} - owned by ${actualOwner}, but requested by ${owner}. Use --force to override.`
    };
  }

  const isGenerated = await isTextorGenerated(filePath);
  if (!isGenerated) {
    return { 
      valid: false, 
      reason: 'not-generated', 
      message: `Refusing to operate on ${filePath} - not generated by Textor. Use --force to override.` 
    };
  }

  if (!expectedHash) {
    return {
      valid: false,
      reason: 'not-in-state',
      message: `Refusing to operate on ${filePath} - not found in Textor state. Use --force to override.`
    };
  }

  if (!acceptChanges) {
    const content = await readFile(filePath, 'utf-8');
    const currentHash = calculateHash(content, normalization);
    if (currentHash !== expectedHash) {
      return {
        valid: false,
        reason: 'hash-mismatch',
        message: `Refusing to operate on ${filePath} - content has been modified. Use --accept-changes or --force to override.`
      };
    }
  }

  return { valid: true };
}

export async function safeDelete(filePath, options = {}) {
  const { force = false, expectedHash = null, acceptChanges = false, owner = null, actualOwner = null } = options;
  
  if (!existsSync(filePath)) {
    return { deleted: false, reason: 'not-found' };
  }
  
  const integrity = await verifyFileIntegrity(filePath, expectedHash, { 
    force, 
    acceptChanges,
    owner,
    actualOwner
  });
  if (!integrity.valid) {
    return { deleted: false, reason: integrity.reason, message: integrity.message };
  }

  await unlink(filePath);
  return { deleted: true };
}

export async function ensureNotExists(filePath, force = false) {
  if (existsSync(filePath)) {
    if (!force) {
      throw new Error(
        `File already exists: ${filePath}\n` +
        `Use --force to overwrite.`
      );
    }
  }
}

export async function ensureDir(dirPath) {
  await mkdir(dirPath, { recursive: true });
}

async function isSafeToDeleteDir(dirPath, stateFiles = {}, options = {}) {
  try {
    const files = await readdir(dirPath);
    
    const results = await Promise.all(
      files.map(async file => {
        const filePath = path.join(dirPath, file);
        const stats = await stat(filePath);
        
        if (stats.isDirectory()) {
          return await isSafeToDeleteDir(filePath, stateFiles, options);
        }
        
        const normalizedPath = path.relative(process.cwd(), filePath).replace(/\\/g, '/');
        const fileState = stateFiles[normalizedPath];
        const integrity = await verifyFileIntegrity(filePath, fileState?.hash, {
          ...options,
          actualOwner: fileState?.owner
        });
        return integrity.valid;
      })
    );

    return results.every(Boolean);
  } catch {
    return false;
  }
}

export async function safeDeleteDir(dirPath, options = {}) {
  const { force = false, stateFiles = {} } = options;
  if (!existsSync(dirPath)) {
    return { deleted: false, reason: 'not-found' };
  }

  const isSafe = force || await isSafeToDeleteDir(dirPath, stateFiles, options);
  
  if (isSafe) {
    await rm(dirPath, { recursive: true, force: true });
    return { deleted: true };
  }

  return {
    deleted: false,
    reason: 'contains-non-generated-or-modified',
    message: `Directory contains non-generated or modified files: ${dirPath}. Use --force to override.`
  };
}

export async function writeFileWithSignature(filePath, content, signature, normalization = 'normalizeEOL') {
  await ensureDir(path.dirname(filePath));
  
  let finalContent = signature + '\n' + content;
  
  if (signature.includes(':begin')) {
    const endSignature = signature.replace(':begin', ':end');
    finalContent = signature + '\n' + content + '\n' + endSignature;
  }

  await writeFile(filePath, finalContent, 'utf-8');
  
  return calculateHash(finalContent, normalization);
}

export function getSignature(config, type) {
  const base = config.signatures[type] || config.signatures.typescript;
  if (config.hashing?.useMarkers) {
    return base.replace('Textor', 'Textor:begin');
  }
  return base;
}

export async function updateSignature(filePath, oldPath, newPath) {
  if (!existsSync(filePath)) {
    return;
  }

  let content = await readFile(filePath, 'utf-8');
  
  content = content.replace(
    new RegExp(oldPath.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'),
    newPath
  );
  
  await writeFile(filePath, content, 'utf-8');
}

export async function safeMove(fromPath, toPath, options = {}) {
  const { 
    force = false, 
    expectedHash = null, 
    acceptChanges = false, 
    normalization = 'normalizeEOL',
    owner = null,
    actualOwner = null
  } = options;
  
  if (!existsSync(fromPath)) {
    throw new Error(`Source file not found: ${fromPath}`);
  }

  if (existsSync(toPath) && !force) {
    throw new Error(
      `Destination already exists: ${toPath}\n` +
      `Use --force to overwrite.`
    );
  }

  const integrity = await verifyFileIntegrity(fromPath, expectedHash, { 
    force, 
    acceptChanges, 
    normalization,
    owner,
    actualOwner
  });
  if (!integrity.valid) {
    throw new Error(integrity.message);
  }

  await ensureDir(path.dirname(toPath));
  await rename(fromPath, toPath);
  
  await updateSignature(toPath, fromPath, toPath);
  
  // Return new hash because updateSignature might have changed it
  const content = await readFile(toPath, 'utf-8');
  return calculateHash(content, normalization);
}

export async function isEmptyDir(dirPath) {
  if (!existsSync(dirPath)) {
    return true;
  }

  const files = await readdir(dirPath);
  return files.length === 0;
}

export async function scanDirectory(dir, fileSet) {
  const files = await readdir(dir);
  for (const file of files) {
    const fullPath = path.join(dir, file);
    const stats = await stat(fullPath);
    if (stats.isDirectory()) {
      if (file === 'node_modules' || file === '.git' || file === '.textor') continue;
      await scanDirectory(fullPath, fileSet);
    } else {
      const relativePath = path.relative(process.cwd(), fullPath).replace(/\\/g, '/');
      fileSet.add(relativePath);
    }
  }
}

export function inferKind(filePath, config) {
  const normalizedFilePath = path.resolve(filePath).replace(/\\/g, '/');
  const relativeFromCwd = path.relative(process.cwd(), normalizedFilePath).replace(/\\/g, '/');

  // Check kindRules first (precedence)
  if (config.kindRules && Array.isArray(config.kindRules)) {
    for (const rule of config.kindRules) {
      if (rule.match && rule.kind) {
        // Simple glob-to-regex conversion for ** and *
        const regexStr = rule.match
          .replace(/[.+^${}()|[\]\\]/g, '\\$&') // Escape regex special chars
          .replace(/\*\*/g, '(.+)')             // ** matches anything
          .replace(/\*/g, '([^/]+)');            // * matches one segment
        
        const regex = new RegExp(`^${regexStr}$`);
        if (regex.test(relativeFromCwd) || regex.test(normalizedFilePath)) {
          return rule.kind;
        }
      }
    }
  }

  const pagesRoot = path.resolve(process.cwd(), config.paths.pages || 'src/pages').replace(/\\/g, '/');
  const featuresRoot = path.resolve(process.cwd(), config.paths.features || 'src/features').replace(/\\/g, '/');
  const componentsRoot = path.resolve(process.cwd(), config.paths.components || 'src/components').replace(/\\/g, '/');

  const ext = path.extname(normalizedFilePath);

  if (normalizedFilePath.startsWith(pagesRoot)) {
    if (ext === '.ts' || ext === '.js') return 'endpoint';
    return 'route';
  }

  if (normalizedFilePath.startsWith(featuresRoot)) {
    const relativePath = path.relative(featuresRoot, normalizedFilePath).replace(/\\/g, '/');
    const parts = relativePath.split('/');
    
    // If it's directly in the features root
    if (parts.length === 1) return 'feature';

    const fileName = parts[parts.length - 1];
    const featureDir = path.dirname(relativePath).replace(/\\/g, '/');
    
    // Main feature file can be FeatureName.astro or index.astro
    const featureName = toPascalCase(featureDir);
    const possiblePascalName = featureName + (config.naming.featureExtension || '.astro');
    const possibleIndexName = 'index' + (config.naming.featureExtension || '.astro');
    
    if (path.dirname(relativePath) !== '.' && (fileName === possiblePascalName || fileName === possibleIndexName)) {
      // It's in the top level of its feature directory
      if (parts.length === (featureDir.split('/').length + 1)) {
        return 'feature';
      }
    }
    
    return 'feature-file';
  }

  if (normalizedFilePath.startsWith(componentsRoot)) {
    const relativePath = path.relative(componentsRoot, normalizedFilePath).replace(/\\/g, '/');
    const parts = relativePath.split('/');
    
    if (parts.length === 1) return 'component';
    
    const componentDir = parts[0];
    const fileName = parts[parts.length - 1];
    const componentName = toPascalCase(componentDir);
    
    const possibleComponentName = componentName + (config.naming.componentExtension || '.tsx');
    const possibleIndexName = 'index' + (config.naming.componentExtension || '.tsx');
    
    if (parts.length === 2 && (fileName === possibleComponentName || fileName === possibleIndexName)) {
      return 'component';
    }
    
    return 'component-file';
  }

  return 'unknown';
}

/**
 * Safely joins path segments and ensures the result is within the basePath.
 * @param {string} basePath The base directory that must contain the result
 * @param {...string} segments Path segments to join
 * @returns {string} The joined path
 * @throws {Error} If a path traversal attempt is detected
 */
export function secureJoin(basePath, ...segments) {
  const joinedPath = path.join(basePath, ...segments);
  const resolvedBase = path.resolve(basePath);
  const resolvedJoined = path.resolve(joinedPath);
  
  const relative = path.relative(resolvedBase, resolvedJoined);
  
  if (relative.startsWith('..') || path.isAbsolute(relative)) {
    throw new Error(`Security error: Path traversal attempt detected: ${joinedPath} is outside of ${basePath}`);
  }
  
  return joinedPath;
}

export async function cleanupEmptyDirs(dirPath, rootPath) {
  const normalizedDir = path.resolve(dirPath);
  const normalizedRoot = path.resolve(rootPath);
  
  if (normalizedDir === normalizedRoot || !normalizedDir.startsWith(normalizedRoot)) {
    return;
  }

  if (await isEmptyDir(normalizedDir)) {
    await rmdir(normalizedDir);
    await cleanupEmptyDirs(path.dirname(normalizedDir), rootPath);
  }
}

/**
 * Formats a list of files using the specified tool.
 * @param {string[]} filePaths 
 * @param {'prettier' | 'biome' | 'none'} tool 
 */
export async function formatFiles(filePaths, tool) {
    if (tool === 'none' || !filePaths.length) return;
    
    // Quote paths to handle spaces
    const paths = filePaths.map(p => `"${p}"`).join(' ');
    
    if (tool === 'prettier') {
        try {
            await execAsync(`npx prettier --write ${paths}`);
        } catch (error) {
            // Silently fail if prettier is not available or fails
        }
    } else if (tool === 'biome') {
        try {
            await execAsync(`npx biome format --write ${paths}`);
        } catch (error) {
            // Silently fail
        }
    }
}
