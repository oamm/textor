import { readFile, writeFile, mkdir, unlink, rmdir, rename, readdir, stat, rm } from 'fs/promises';
import { existsSync } from 'fs';
import path from 'path';
import { createHash } from 'crypto';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

export function calculateHash(content) {
  return createHash('sha256').update(content).digest('hex');
}

export async function isTextorGenerated(filePath, customSignatures = []) {
  if (!existsSync(filePath)) {
    return false;
  }

  try {
    const content = await readFile(filePath, 'utf-8');
    const signatures = ['@generated by Textor', ...customSignatures];
    return signatures.some(sig => content.includes(sig));
  } catch {
    return false;
  }
}

export async function verifyFileIntegrity(filePath, expectedHash, options = {}) {
  const { force = false, acceptChanges = false } = options;
  
  if (force) return { valid: true };

  const isGenerated = await isTextorGenerated(filePath);
  if (!isGenerated) {
    return { 
      valid: false, 
      reason: 'not-generated', 
      message: `Refusing to operate on ${filePath} - not generated by Textor. Use --force to override.` 
    };
  }

  if (!expectedHash) {
    return {
      valid: false,
      reason: 'not-in-state',
      message: `Refusing to operate on ${filePath} - not found in Textor state. Use --force to override.`
    };
  }

  if (!acceptChanges) {
    const content = await readFile(filePath, 'utf-8');
    const currentHash = calculateHash(content);
    if (currentHash !== expectedHash) {
      return {
        valid: false,
        reason: 'hash-mismatch',
        message: `Refusing to operate on ${filePath} - content has been modified. Use --accept-changes or --force to override.`
      };
    }
  }

  return { valid: true };
}

export async function safeDelete(filePath, options = {}) {
  const { force = false, expectedHash = null, acceptChanges = false } = options;
  
  if (!existsSync(filePath)) {
    return { deleted: false, reason: 'not-found' };
  }

  const integrity = await verifyFileIntegrity(filePath, expectedHash, { force, acceptChanges });
  if (!integrity.valid) {
    return { deleted: false, reason: integrity.reason, message: integrity.message };
  }

  await unlink(filePath);
  return { deleted: true };
}

export async function ensureNotExists(filePath, force = false) {
  if (existsSync(filePath)) {
    if (!force) {
      throw new Error(
        `File already exists: ${filePath}\n` +
        `Use --force to overwrite.`
      );
    }
  }
}

export async function ensureDir(dirPath) {
  await mkdir(dirPath, { recursive: true });
}

async function isSafeToDeleteDir(dirPath, stateFiles = {}, options = {}) {
  const { force = false, acceptChanges = false } = options;
  try {
    const files = await readdir(dirPath);
    
    const results = await Promise.all(
      files.map(async file => {
        const filePath = path.join(dirPath, file);
        const stats = await stat(filePath);
        
        if (stats.isDirectory()) {
          return await isSafeToDeleteDir(filePath, stateFiles, options);
        }
        
        const normalizedPath = path.relative(process.cwd(), filePath).replace(/\\/g, '/');
        const fileState = stateFiles[normalizedPath];
        const integrity = await verifyFileIntegrity(filePath, fileState?.hash, options);
        return integrity.valid;
      })
    );

    return results.every(Boolean);
  } catch {
    return false;
  }
}

export async function safeDeleteDir(dirPath, options = {}) {
  const { force = false, stateFiles = {} } = options;
  if (!existsSync(dirPath)) {
    return { deleted: false, reason: 'not-found' };
  }

  const isSafe = force || await isSafeToDeleteDir(dirPath, stateFiles, options);
  
  if (isSafe) {
    await rm(dirPath, { recursive: true, force: true });
    return { deleted: true };
  }

  return {
    deleted: false,
    reason: 'contains-non-generated-or-modified',
    message: `Directory contains non-generated or modified files: ${dirPath}. Use --force to override.`
  };
}

export async function writeFileWithSignature(filePath, content, signature) {
  await ensureDir(path.dirname(filePath));
  
  const contentWithSignature = signature + '\n' + content;
  await writeFile(filePath, contentWithSignature, 'utf-8');
  
  return calculateHash(contentWithSignature);
}

export async function updateSignature(filePath, oldPath, newPath) {
  if (!existsSync(filePath)) {
    return;
  }

  let content = await readFile(filePath, 'utf-8');
  
  content = content.replace(
    new RegExp(oldPath.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'),
    newPath
  );
  
  await writeFile(filePath, content, 'utf-8');
}

export async function safeMove(fromPath, toPath, options = {}) {
  const { force = false, expectedHash = null, acceptChanges = false } = options;
  
  if (!existsSync(fromPath)) {
    throw new Error(`Source file not found: ${fromPath}`);
  }

  if (existsSync(toPath) && !force) {
    throw new Error(
      `Destination already exists: ${toPath}\n` +
      `Use --force to overwrite.`
    );
  }

  const integrity = await verifyFileIntegrity(fromPath, expectedHash, { force, acceptChanges });
  if (!integrity.valid) {
    throw new Error(integrity.message);
  }

  await ensureDir(path.dirname(toPath));
  await rename(fromPath, toPath);
  
  await updateSignature(toPath, fromPath, toPath);
  
  // Return new hash because updateSignature might have changed it
  const content = await readFile(toPath, 'utf-8');
  return calculateHash(content);
}

export async function isEmptyDir(dirPath) {
  if (!existsSync(dirPath)) {
    return true;
  }

  const files = await readdir(dirPath);
  return files.length === 0;
}

export async function scanDirectory(dir, fileSet) {
  const files = await readdir(dir);
  for (const file of files) {
    const fullPath = path.join(dir, file);
    const stats = await stat(fullPath);
    if (stats.isDirectory()) {
      await scanDirectory(fullPath, fileSet);
    } else {
      const relativePath = path.relative(process.cwd(), fullPath).replace(/\\/g, '/');
      fileSet.add(relativePath);
    }
  }
}

export function inferKind(filePath, config) {
  const pagesRoot = path.resolve(process.cwd(), config.paths.pages || 'src/pages').replace(/\\/g, '/');
  const featuresRoot = path.resolve(process.cwd(), config.paths.features || 'src/features').replace(/\\/g, '/');
  const componentsRoot = path.resolve(process.cwd(), config.paths.components || 'src/components').replace(/\\/g, '/');

  const normalizedFilePath = path.resolve(filePath).replace(/\\/g, '/');

  if (normalizedFilePath.startsWith(pagesRoot)) return 'page';
  if (normalizedFilePath.startsWith(featuresRoot)) return 'feature';
  if (normalizedFilePath.startsWith(componentsRoot)) return 'component';
  return 'unknown';
}

/**
 * Safely joins path segments and ensures the result is within the basePath.
 * @param {string} basePath The base directory that must contain the result
 * @param {...string} segments Path segments to join
 * @returns {string} The joined path
 * @throws {Error} If a path traversal attempt is detected
 */
export function secureJoin(basePath, ...segments) {
  const joinedPath = path.join(basePath, ...segments);
  const resolvedBase = path.resolve(basePath);
  const resolvedJoined = path.resolve(joinedPath);
  
  const relative = path.relative(resolvedBase, resolvedJoined);
  
  if (relative.startsWith('..') || path.isAbsolute(relative)) {
    throw new Error(`Security error: Path traversal attempt detected: ${joinedPath} is outside of ${basePath}`);
  }
  
  return joinedPath;
}

export async function cleanupEmptyDirs(dirPath, rootPath) {
  const normalizedDir = path.resolve(dirPath);
  const normalizedRoot = path.resolve(rootPath);
  
  if (normalizedDir === normalizedRoot || !normalizedDir.startsWith(normalizedRoot)) {
    return;
  }

  if (await isEmptyDir(normalizedDir)) {
    await rmdir(normalizedDir);
    await cleanupEmptyDirs(path.dirname(normalizedDir), rootPath);
  }
}

/**
 * Formats a list of files using the specified tool.
 * @param {string[]} filePaths 
 * @param {'prettier' | 'biome' | 'none'} tool 
 */
export async function formatFiles(filePaths, tool) {
    if (tool === 'none' || !filePaths.length) return;
    
    // Quote paths to handle spaces
    const paths = filePaths.map(p => `"${p}"`).join(' ');
    
    if (tool === 'prettier') {
        try {
            await execAsync(`npx prettier --write ${paths}`);
        } catch (error) {
            // Silently fail if prettier is not available or fails
        }
    } else if (tool === 'biome') {
        try {
            await execAsync(`npx biome format --write ${paths}`);
        } catch (error) {
            // Silently fail
        }
    }
}
