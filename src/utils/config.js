import { readFile, writeFile, mkdir } from 'fs/promises';
import { existsSync } from 'fs';
import path from 'path';

const CONFIG_DIR = '.textor';
const CONFIG_FILE = 'config.json';

/**
 * @typedef {Object} TextorConfig
 * @property {Object} paths
 * @property {string} paths.pages
 * @property {string} paths.features
 * @property {string} paths.components
 * @property {string} paths.layouts
 * @property {Object} importAliases
 * @property {string} importAliases.layouts
 * @property {string} importAliases.features
 * @property {Object} naming
 * @property {string} naming.routeExtension
 * @property {string} naming.featureExtension
 * @property {string} naming.componentExtension
 * @property {string} naming.hookExtension
 * @property {string} naming.testExtension
 * @property {Object} signatures
 * @property {string} signatures.astro
 * @property {string} signatures.typescript
 * @property {string} signatures.javascript
 * @property {Object} features
 * @property {boolean} features.createComponentsDir
 * @property {boolean} features.createScriptsDir
 * @property {string} features.scriptsIndexFile
 * @property {Object} components
 * @property {boolean} components.createComponentsDir
 * @property {boolean} components.createContext
 * @property {boolean} components.createHook
 * @property {boolean} components.createTests
 * @property {boolean} components.createConfig
 * @property {boolean} components.createConstants
 */

/**
 * Default configuration for Textor
 * @type {TextorConfig}
 */
export const DEFAULT_CONFIG = {
  paths: {
    pages: 'src/pages',
    features: 'src/features',
    components: 'src/components',
    layouts: 'src/layouts'
  },
  importAliases: {},
  naming: {
    routeExtension: '.astro',
    featureExtension: '.astro',
    componentExtension: '.astro',
    hookExtension: '.ts',
    testExtension: '.test.tsx'
  },
  signatures: {
    astro: '<!-- @generated by Textor -->',
    typescript: '// @generated by Textor',
    javascript: '// @generated by Textor'
  },
  features: {
    createComponentsDir: true,
    createScriptsDir: true,
    scriptsIndexFile: 'Scripts/index.ts'
  },
  components: {
    createComponentsDir: false,
    createContext: true,
    createHook: true,
    createTests: true,
    createConfig: true,
    createConstants: true
  }
};

/**
 * Gets the absolute path to the .textor directory.
 * @returns {string}
 */
export function getConfigDir() {
  return path.join(process.cwd(), CONFIG_DIR);
}

/**
 * Gets the absolute path to the config.json file.
 * @returns {string}
 */
export function getConfigPath() {
  return path.join(getConfigDir(), CONFIG_FILE);
}

/**
 * Checks if the configuration file exists.
 * @returns {boolean}
 */
export function configExists() {
  return existsSync(getConfigPath());
}

/**
 * Loads the configuration from config.json and merges it with DEFAULT_CONFIG.
 * @returns {Promise<TextorConfig>}
 * @throws {Error} If configuration not found or invalid
 */
export async function loadConfig() {
  const configPath = getConfigPath();
  
  if (!existsSync(configPath)) {
    throw new Error(
      `Textor configuration not found at ${configPath}\n` +
      `Run 'textor init' to create it.`
    );
  }

  try {
    const content = await readFile(configPath, 'utf-8');
    const config = JSON.parse(content);
    const merged = deepMerge(DEFAULT_CONFIG, config);
    validateConfig(merged);
    return merged;
  } catch (error) {
    if (error instanceof SyntaxError) {
      throw new Error(`Failed to parse config: Invalid JSON at ${configPath}`);
    }
    throw new Error(`Failed to load config: ${error.message}`);
  }
}

/**
 * Saves the configuration to config.json.
 * @param {TextorConfig} config Configuration to save
 * @param {boolean} [force=false] Whether to overwrite existing config
 * @returns {Promise<string>} Path to the saved config file
 * @throws {Error} If config exists and force is false
 */
export async function saveConfig(config, force = false) {
  const configPath = getConfigPath();
  
  if (existsSync(configPath) && !force) {
    throw new Error(
      `Configuration already exists at ${configPath}\n` +
      `Use --force to overwrite.`
    );
  }

  validateConfig(config);

  const configDir = getConfigDir();
  if (!existsSync(configDir)) {
    await mkdir(configDir, { recursive: true });
  }

  await writeFile(configPath, JSON.stringify(config, null, 2) + '\n', 'utf-8');
  return configPath;
}

/**
 * Deeply merges source object into target object.
 * @param {Object} target 
 * @param {Object} source 
 * @returns {Object} Merged object
 */
function deepMerge(target, source) {
  const result = { ...target };
  
  for (const key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
        result[key] = deepMerge(target[key] || {}, source[key]);
      } else {
        result[key] = source[key];
      }
    }
  }
  
  return result;
}

/**
 * Validates the configuration object structure.
 * @param {any} config 
 * @throws {Error} If config is invalid
 */
function validateConfig(config) {
  if (!config || typeof config !== 'object') {
    throw new Error('Invalid configuration: must be an object');
  }

  const requiredSections = ['paths', 'naming', 'signatures', 'importAliases'];
  for (const section of requiredSections) {
    if (!config[section] || typeof config[section] !== 'object') {
      throw new Error(`Invalid configuration: missing or invalid "${section}" section`);
    }
  }

  // Validate paths are strings
  for (const [key, value] of Object.entries(config.paths)) {
    if (typeof value !== 'string') {
      throw new Error(`Invalid configuration: "paths.${key}" must be a string`);
    }
  }

  // Validate naming extensions start with dot
  for (const [key, value] of Object.entries(config.naming)) {
    if (typeof value === 'string' && !value.startsWith('.') && value !== '') {
      throw new Error(`Invalid configuration: "naming.${key}" should start with a dot (e.g., ".astro")`);
    }
  }
}

/**
 * Resolves a configured path key to an absolute path.
 * @param {TextorConfig} config 
 * @param {keyof TextorConfig['paths']} pathKey 
 * @returns {string}
 */
export function resolvePath(config, pathKey) {
  const configuredPath = config.paths[pathKey];
  if (!configuredPath) {
    throw new Error(`Path "${pathKey}" not found in configuration`);
  }
  return path.resolve(process.cwd(), configuredPath);
}
